<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js"></script>

<script src="js/gl-matrix.js"></script>
<script src="js/md5.js"></script>
<script src="js/pako.min.js"></script>
<script src="js/utils.js"></script>
<script src="js/recycler.js"></script>
<script src="js/view_manager.js"></script>
<script src="js/scene_manager.js"></script>
<script src="js/sprite_renderer.js"></script>
<script src="js/image_meta.js"></script>
<script src="js/texture_meta.js"></script>
<script src="js/dowge.js"></script>


<style>
body {
  margin: 0;
  padding: 0;
}
.button {
  margin: 1px;
  padding: 5px;
  background-color: lightblue;
  border-style: outset;
  border-radius: 10px;
  border-size: 1px;
  cursor: pointer;
  color: darkblue;
}
.button:hover {
  background-color: yellow;
  color: black;
  border-color: white;
}
.button:disabled {
  background-color: white !important;
  color: silver;
  cursor: not-allowed;
}
.link {
  color: #5555FF;
  cursor: pointer;
}
.link:hover {
  color: lightblue;
  text-decoration: underline;
}
.sprite {
  border-width: 2px;
  border-style: solid;
  border-color: lightblue;
}
.sprite:hover {
  border-color: yellow;
}
#glCanvas {
  cursor: grab;
}
</style>
<body style="background-color: black">
  <div style="display: flex; flex-direction: row;">
    <canvas id="glCanvas" width="1200" height="1200" style="width: 600; height: 600; image-rendering: pixelated;"></canvas>
    <div id="editbar" style="display: none;">
      <div style="display: flex; flex-direction: row">
        <button id="importButton" class="button" style="display:none;">Import...</button>
        <button id="changeBgColor" class="button" style="display:none;">Change background</button>
      </div>
      <div id="cover" style="position: fixed; width: 100vw; height: 100vh; background-color: rgba(20, 26, 36, 0.98); left: 0; top: 0; display:none"></div>
      <div id="importOverlay" style="position: absolute; width: 100vw; left: 0; top: 0; display:none">
        <div style="display: flex; flex-direction: row; margin: 20px; color: silver">
          <button class="button" id="okImport" style="width: 80px; height: 30px; background-color: green;">IMPORT</button>
          <button class="button" id="cancelImport" style="width: 80px; height: 30px; background-color: red;">CANCEL</button>
          <div id="recentPaths" style="padding: 2px"></div>
        </div>
        <div id="dir" style="width: 800px; margin: 20px 50px"></div>
      </div>

      <div id="thumb" style="display: flex; flex-direction: column;">
        <canvas id="spritesheet" style="width: 200px; height: 100px;" ></canvas>
        <button id="playButton" style="display:none"></button>
        <button id="saveButton" style="display:none" ></button>
        <div id="noticeDiv" style="width: 200px; display:none" ></div>
      </div>
      <div id="sprites" style="width: 300px; display: flex; flex-wrap: wrap">
      </div>
    </div>
  </div>
  <div id="editor" style="display: none; flex-direction: column;">
  </div>
  <pre id="pre-metadata" style="display: none;">
    <div id="metadata" style="color: green;"></div>    
  </pre>
</body>



<script>
    if(location.search.indexOf("edit")>=0) {
      document.getElementById('editbar').style.display = '';
      document.getElementById('editor').style.display = 'flex';
      document.getElementById('pre-metadata').style.display = '';
    }
        let currentPath = '/Users/vincent/Google Drive/Project/Demo4';
        let fileSelection = -1;
        let meta = null;
        let imgData = [];
        let canvases = [];

        const R = 0, G = 1, B = 2, A = 3;

        function initialize() {
          meta = {};
          checkImportButton(false);
          checkSpriteList(meta);   
        }

        function checkImportButton(enableImport) {
          const importButton = document.getElementById('importButton');
          const okImport = document.getElementById('okImport');
          okImport.disabled = !enableImport;

          if(importButton.getAttribute('initialized')!="initialized") {
            importButton.setAttribute('initialized', 'initialized');
            importButton.style.height = "25px";
            importButton.classList.add("button");
            importButton.style.display = "";
            importButton.addEventListener('click', e => {
              const importOverlay = document.getElementById('importOverlay');
              importOverlay.style.display = "";
              document.getElementById('cover').style.display = "";
              fileSelection = -1;
              fillDir(currentPath);
            });

            const changeBgColor = document.getElementById('changeBgColor');
            changeBgColor.style.height = "25px";
            changeBgColor.classList.add("button");
            changeBgColor.style.display = "";
            changeBgColor.addEventListener('click', e => {
              const color = Math.floor(Math.random() * 0xFFFFFF);
              document.body.style.backgroundColor = "#" + color.toString(16);
              const gl = document.querySelector('#glcanvas').getContext('webgl');
              gl.getSpriteRenderer().setBackgroundColor(color);
            });

            const cancelImport = document.getElementById('cancelImport');
            cancelImport.addEventListener('click', e => {
              const importOverlay = document.getElementById('importOverlay');
              importOverlay.style.display = "none";
              document.getElementById('cover').style.display = "none";
            });

            const okImport = document.getElementById('okImport');
            okImport.addEventListener('click', e => {
              importOverlay.style.display = "none";
              document.getElementById('cover').style.display = "none";
              if(fileSelection >= 0) {
                compressCanvas(imgData.filter((data, index) => index == fileSelection));
              } else {
                compressCanvas(imgData);
              }

              let recentPaths = localStorage.getItem("recentPaths");
              if(!recentPaths) {
                recentPaths = [];
              } else {
                recentPaths = JSON.parse(recentPaths);
              }
              if(recentPaths.indexOf(currentPath) < 0) {
                recentPaths.unshift(currentPath);
                if(recentPaths.length > 5) {
                  recentPaths.pop();
                }
                localStorage.setItem("recentPaths", JSON.stringify(recentPaths));
              }
            });
          }
        }

        function emptyRow(data, width, height, y) {
          for(var i=0; i<width; i++) {
            if(getPixel(data, i, y, width, A)) {
              return false;
            }
          }
          return true;
        }

        function emptyCol(data, width, height, x) {
          for(var i=0; i<height; i++) {
            if(getPixel(data, x, i, width, A)) {
              return false;
            }
          }
          return true;
        }

        function getPixel(data, x, y, width, rgbaOffset) {
          var index = (x + y * width) * 4 + rgbaOffset;
          return data[index];
        }

        const canvasCache = {};

        function process(imgData, index, img) {
          let canvas = document.createElement('canvas');
          var data = imgData[index] = {
            img,
            crop: { 
              minX: 0, minY: 0, 
              maxX: img.naturalWidth-1, 
              maxY: img.naturalHeight-1,
            },
            canvas,
            orgSize: {
              width: img.naturalWidth,
              height: img.naturalHeight,
            },
          };

          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          canvas.getContext('2d').drawImage(img,0, 0, img.naturalWidth, img.naturalHeight);
          data.crop = Utils.getCrop(canvas);
          // hotspot is center of canvas
          data.hotspot = {
            x: (canvas.width/2) - data.crop.minX,
            y: (canvas.height/2) - data.crop.minY,
          };
          canvas.width = data.crop.maxX - data.crop.minX + 1;
          canvas.height = data.crop.maxY - data.crop.minY + 1;
          canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
          canvas.getContext('2d').drawImage(img, -data.crop.minX, -data.crop.minY);
          data.md5 = getMD5(canvas.getContext('2d'), data);
          if(canvasCache[data.md5]) {
            canvas = canvasCache[data.md5];
          } else {
            canvasCache[data.md5] = canvas;
            canvas.setAttribute('md5', data.md5);
            canvas.style.width = "50px";
          }

          checkImgData(imgData);
        }

        function getMD5(context, data) {
          const { width, height } = context.canvas;
          const { minX, minY, maxX, maxY } = data.crop;
          const { x, y } = data.hotspot;
          const imgData = context.getImageData(minX, minY, maxX-minX+1, maxY-minY+1).data;
          return md5(imgData);
        }

        function getFit(canvases, rowCount) {
          rowCount = Math.min(canvases.length, Math.max(1,rowCount));
          let w = 0, h = 0;
          for(var i=0; i<rowCount; i++) {
            w += canvases[i].width;
            h = Math.max(h, canvases[i].height);
          }
          let wrap = 0, maxH = 0;
          for(var i=rowCount; i<canvases.length; i++) {
            maxH = Math.max(canvases[i].height, maxH);
            if(wrap + canvases[i].width > w) {
              wrap = 0;
              h += maxH;
              maxH = 0;
            }
            wrap += canvases[i].width;
            maxH = Math.max(canvases[i].height, maxH);
            w = Math.max(wrap, w);
          }
          h += maxH;
          return { width: w, height: h };
        }

        function checkImgData(imgData) {
            checkImportButton(imgData.length > 0 && imgData.filter(a => a).length === imgCount);
        }

        function fixSize(canvas) {
          canvas.style.width = canvas.width/2 + "px";
          canvas.style.height = canvas.height/2 + "px";
        }

        function refreshCanvas(canvas, canvases) {
          fixSize(canvas);
          let x = 0, y = 0, maxH = 0;
          const crops = {};
          for(let i=0; i<canvases.length; i++) {
            if(x + canvases[i] .width > canvas.width) {
              x = 0; y += maxH;
              maxH = 0;
            }
            canvas.getContext('2d').drawImage(canvases[i], x, y);
            crops[canvases[i].getAttribute('md5')] = {
                x, y, width: canvases[i].width, height: canvases[i].height,
            };
            x += canvases[i].width;
            maxH = Math.max(canvases[i].height, maxH);
          }

          for(let i=0; i<imgData.length; i++) {
            imgData[i].spritesheet = canvas;
            imgData[i].spritesheetCrop = crops[imgData[i].md5];
          }
        }

        function checkSpriteList(meta) {
          const sprites = document.getElementById('sprites');
          sprites.innerHTML = "";
          const xhr = new XMLHttpRequest();
          xhr.open("GET", "/api/list-sprites", true);
          xhr.addEventListener('load', e => {
            const xhr = e.currentTarget;
            if (xhr.status == 200 && xhr.responseText) {
              const { images } = JSON.parse(xhr.responseText);
              images.forEach(src => {
                const div = sprites.appendChild(document.createElement('div'));
                div.style.margin = "2px";
                div.style.padding = "2px";
                div.style.width = "60px";
                div.style.height = "60px";
                Meta.loadImage(`${src}?${performance.now()}`, (img, meta) => {
                  Meta.addImage(img);
                  div.style.backgroundImage = `url('${img.src}')`;
                  div.style.backgroundSize = "cover";
                  div.style.backgroundPosition = "center";
                  div.style.cursor = "pointer";
                  div.classList.add('sprite');
                  div.addEventListener('click', e => useSpriteSheet(meta.name));
                  checkSaveButton();
                });
              });
            }
          });
          xhr.send();
        }

        function checkPlayButton() {
            const playButton = document.getElementById('playButton');
            const isEnabled = meta && meta.name;
            playButton.disabled = !isEnabled;
            playButton.style.display = isEnabled ? "" : "none";

            if(playButton.getAttribute('initialized') != 'initialized') {
              playButton.setAttribute('initialized', 'initialized');
              playButton.innerText = "PLAY";
              playButton.style.height = "25px";
              playButton.classList.add("button");
              playButton.addEventListener('click', e => {
                  meta = {};
                  initScene(scene);
                  checkPlayButton();
                  const canvas = document.getElementById('spritesheet');
                  generateEditor(meta, canvas);         
                  displayMeta(meta, canvas);
                  checkPlayButton();
                  checkSaveButton();
              });                  
            }
        }

        function checkSaveButton() {
          const saveButton = document.getElementById('saveButton');
          const spriteData = Meta.getSpriteData(meta.name);

          const isEnabled = meta && meta.name && (!spriteData.meta || meta.hash !== spriteData.meta.hash);

//          saveButton.disabled = !isEnabled;

          saveButton.style.display = meta.name ? "" : "none";
          if(saveButton.getAttribute('initialized')!="initialized") {
            saveButton.setAttribute('initialized', 'initialized');
            saveButton.innerText = "SAVE";
            saveButton.style.height = "25px";
            saveButton.classList.add("button");
            saveButton.addEventListener('click', e => {
                saveButton.disabled = true;
                const noticeDiv = document.getElementById('noticeDiv');
                noticeDiv.innerText = "";
                const xhr = new XMLHttpRequest();
                xhr.open("POST", "/api/save", true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.addEventListener('load', e => {
                  const xhr = e.currentTarget;
                  if (xhr.status == 200 && xhr.responseText) {
                    noticeDiv.style.display = "";
                    const response = JSON.parse(xhr.responseText);
                    if(response.error) {
                        noticeDiv.style.color = "red";
                        noticeDiv.innerText = response.error;
                    } else if(response.success) {
                        noticeDiv.style.color = "green";
                        noticeDiv.innerText = response.success;
                    }
                    setTimeout(() => {
                        noticeDiv.innerText = "";
                    }, 5000);
                    checkSpriteList(meta);
                  }
                });
                xhr.send(JSON.stringify({
                    name: meta.name,
                    data: document.getElementById('spritesheet').toDataURL()
                }));
            });            
          }
        }

        function useSpriteSheet(name) {
          const sheet = Meta.getSpriteData(name);
          if(!sheet) {
            return;
          }
          const canvas = document.getElementById('spritesheet');
          canvas.texture = null;          
          canvas.width = sheet.canvas.width;
          canvas.height = sheet.canvas.height;
          fixSize(canvas);
          canvas.style.maxWidth = "300px";
          canvas.style.maxHeight = "300px";
          canvas.style.border = "2px solid silver";
          canvas.style.margin = "1px";
          canvas.style.padding = "1px";
          canvas.style.display = "";
          canvas.getContext('2d').drawImage(sheet.canvas, 0, 0);

          meta = JSON.parse(JSON.stringify(sheet.meta));

          onMetaChange(meta, canvas);
          generateEditor(meta, canvas);         
          checkPlayButton();
        }

        function compressCanvas(imgData) {
          const hashes = {};
          canvases = [];
          for(var i=0; i<imgData.length; i++) {
            if(!hashes[imgData[i].md5]) {
              hashes[imgData[i].md5] = true;
              canvases.push(canvasCache[imgData[i].md5]);
            }
          }

          let fit = null;
          for(var c=1; c<=canvases.length; c++) {
            fit = getFit(canvases, c);
            if (fit.width > fit.height) {
              break;
            }
          }

          const canvas = document.getElementById('spritesheet');
          canvas.texture = null;          
          canvas.width = fit.width;
          canvas.height = fit.height;
          fixSize(canvas);
          canvas.style.maxWidth = "300px";
          canvas.style.maxHeight = "300px";
          canvas.style.border = "2px solid black";
          canvas.style.margin = "1px";
          canvas.style.padding = "1px";
          canvas.style.display = "";

          refreshCanvas(canvas, canvases);
          meta = generateMetaData(imgData, canvas.width, canvas.height);

          onMetaChange(meta, canvas);
          generateEditor(meta, canvas);
          Meta.addImage(canvas);
        }

        function displayMeta(meta, canvas) {
          document.getElementById('metadata').innerText = !meta.name ? '' :
            JSON.stringify(meta, null, '  ');
        }

        function cleanObject(obj, validProperties) {
          for(let p in obj) {
            if(validProperties.indexOf(p) < 0) {
              delete obj[p];
            }
          }
        }

        function sanitizeMeta(meta) {
          cleanObject(meta, [ 'name', 'canvas', 'animation', 'frames', 'hash' ]);
          cleanObject(meta.canvas, [ 'width', 'height' ]);
          cleanObject(meta.animation, [ 'rows' ]);
          meta.animation.rows.forEach(row => {
            cleanObject(row, [ 'label', 'range', 'frameRate', 'locked' ]);
          });
          meta.frames.forEach(frame => {
            cleanObject(frame, [ 'range', 'hotspot', 'crop' ]);
            cleanObject(frame.hotspot, [ 'x', 'y' ]);
            cleanObject(frame.crop, [ 'x', 'y', 'width', 'height' ]);
          });
        }

        function validateMeta(meta) {
          for(let a in meta.animation.rows) {
            if(!meta.animation.rows[a].range) {
                meta.animation.rows[a].range = "";
            }
            if(!meta.animation.rows[a].frameRate) {
                meta.animation.rows[a].frameRate = 60;
            }
          }
          delete meta.hash;
          meta.hash = md5(JSON.stringify(meta));
        }

        function onMetaChange(meta, canvas) {
            sanitizeMeta(meta);
            validateMeta(meta);
            displayMeta(meta, canvas);
            Meta.drawMeta(meta, canvas);
            fixSize(canvas);
            checkSaveButton();    
            initScene(scene);
        }

        let selectedIndex = 0;
        let hasHotspot = false;

        function generateEditor(meta, canvas) {
          var editor = document.getElementById('editor');

          function generateInput(div, property, defaultValue) {
              var labelElement = div.appendChild(document.createElement('label'));
              labelElement.for = property;
              labelElement.innerText = property + ": ";
              var input = div.appendChild(document.createElement('input'));
              input.id = property;
              input.value = meta[property] || defaultValue;
              input.addEventListener("keyup", e => {
                var input = e.currentTarget;
                meta[property] = input.value;
                onMetaChange(meta, canvas);
              });          
          }

          editor.innerHTML = "";
          editor.style.backgroundColor = "#ccddaa";
          editor.style.width = document.getElementById('glCanvas').width/2 + "px";

          if(!meta.name) {
            return;
          }

          {
            var div = editor.appendChild(document.createElement('div'));
            div.style.padding = "2px";

            generateInput(div, "name", "");

            var div = editor.appendChild(document.createElement('div'));
            div.style.display = "flex";
            div.style.flexDirection = "row";
            div.style.padding = "2px";

            var cell = div.appendChild(document.createElement('div'));
            cell.style.width = "20px";

            var cell = div.appendChild(document.createElement('div'));
            cell.style.flex = 1;
            cell.style.backgroundColor = "#ddeedd";
            cell.innerText = "LABEL";
            cell.style.margin = 0 

            var cell = div.appendChild(document.createElement('div'));
            cell.style.flex = 1;
            cell.style.backgroundColor = "#ddeedd";
            cell.innerText = "RANGE";

            var cell = div.appendChild(document.createElement('div'));
            cell.style.flex = 1;
            cell.style.backgroundColor = "#ddeedd";
            cell.innerText = "FRAMERATE";

            var cell = div.appendChild(document.createElement('div'));
            cell.style.flex = 1;
            cell.style.backgroundColor = "#ddeedd";
            cell.innerText = "EDIT";
          }

          meta.animation.rows.forEach((row, index) => {
            var div = editor.appendChild(document.createElement('div'));
            div.id = "container";
            div.style.display = "flex";
            div.style.flexDirection = "row";
            div.style.padding = "2px";

            var cell = div.appendChild(document.createElement('div'));
            cell.style.width = "20px";
            var radio = cell.appendChild(document.createElement('input'));
            radio.type = "radio";
            radio.name = "selection";
            radio.value = index;
            radio.checked = index == selectedIndex || selectedIndex<0 && index===0 || selectedIndex >= meta.animation.rows.length && index===0;
            radio.addEventListener("change", e => {
                selectedIndex = radio.value;
                onMetaChange(meta, canvas);
            });

            var cell = div.appendChild(document.createElement('div'));
            cell.style.flex = 1;
            cell.style.padding = "0 1px";
            if(row.locked) {
              var label = cell.appendChild(document.createElement('div'));
              label.innerText = row.label;
            } else {
              var input = cell.appendChild(document.createElement('input'));
              input.value = row.label;
              input.style.width = "100%";
              input.addEventListener("keyup", e => {
                  var input = e.currentTarget;
                  meta.animation.rows[index].label = input.value;
                  onMetaChange(meta, canvas);
              });
            }

            var cell = div.appendChild(document.createElement('div'));
            cell.style.flex = 1;
            cell.style.padding = "0 1px";
            if(row.locked) {
              var label = cell.appendChild(document.createElement('div'));
              label.innerText = row.range;
            } else {
              var input = cell.appendChild(document.createElement('input'));
              input.value = row.range;
              input.style.width = "100%";
              input.addEventListener("keyup", e => {
                  var input = e.currentTarget;
                  meta.animation.rows[index].range = input.value;
                  onMetaChange(meta, canvas);
              });
            }

            var cell = div.appendChild(document.createElement('div'));
            cell.style.flex = 1;
            cell.style.padding = "0 1px";
            var input = cell.appendChild(document.createElement('input'));
            input.value = row.frameRate;
            input.style.width = "100%";
            input.addEventListener("keyup", e => {
                var input = e.currentTarget;
                meta.animation.rows[index].frameRate = input.value;
                onMetaChange(meta, canvas);
                document.querySelector('#glcanvas').getContext('webgl').getTextureFactory().cleanCache(meta.name);
                Meta.addImage(canvas);
            });

            var cell = div.appendChild(document.createElement('div'));
            cell.style.flex = 1;
            if (!row.locked) {
              var button = cell.appendChild(document.createElement('button'));
              button.style.borderRadius = "5px";
              button.style.backgroundColor = "#FFDDDD";
              button.innerText = "remove";
              button.addEventListener("click", e => {
                  meta.animation.rows.splice(index, 1);
                  onMetaChange(meta, canvas);
                  generateEditor(meta, canvas);
              });
            } 
          });

          {
            const div = editor.appendChild(document.createElement('div'));
            {
              const button = div.appendChild(document.createElement('button'));
              button.classList.add("button");
              button.innerText = "ADD";
              button.addEventListener("click", e => {
                  selectedIndex = meta.animation.rows.length;
                  meta.animation.rows.push({
                      label: "animation" + selectedIndex,
                      range: meta.animation.rows[0].range,
                      frameRate: meta.animation.rows[0].frameRate,
                  });
                  onMetaChange(meta, canvas);
                  generateEditor(meta, canvas);
              });
            }
            {
              const button = div.appendChild(document.createElement('button'));
              button.classList.add("button");
              button.innerText = "HOTSPOT";
              button.addEventListener("click", e => {
                hasHotspot = !hasHotspot;
                initScene(scene);
              });
            }
            {
              const button = div.appendChild(document.createElement('button'));
              button.classList.add("button");
              button.innerText = "SPLIT";
              button.disabled = meta.frames.length>1;
              button.addEventListener("click", e => {
                const splitDimension = prompt("Enter sprite dimension (width x height)", "32x32");
                if(splitDimension) {
                  const [ cellWidth, cellHeight ] = splitDimension.split("x").map(a => parseInt(a));
                  const { width, height } = meta.canvas;
                  const cols = Math.ceil(width / cellWidth), rows = Math.ceil(height / cellHeight);
                  let frames = [];
                  for(let y=0; y<rows; y++) {
                    for(let x=0; x<cols; x++) {
                      const top = Math.floor(y * cellHeight);
                      const left = Math.floor(x * cellWidth);
                      const bottom = Math.min(Math.floor((y+1) * cellHeight) - 1, height-1);
                      const right = Math.min(Math.floor((x+1) * cellWidth) - 1, width-1);
                      frames.push({
                        crop: {
                          x: left,
                          y: top,
                          width: right-left+1,
                          height: bottom-top+1,
                        },
                      });
                    }
                  }
                  frames = frames.map(f => {
                    const { crop } = f;
                    return {
                      crop,
                      hotspot: {
                        x: cellWidth / 2,
                        y: cellHeight / 2,
                      },
                    };
                  }).map((f,index) => {
                    const { crop, hotspot } = f;
                    return {
                      crop,
                      hotspot,
                      range: `${index}-${index}`,
                    };
                  });
                  meta.frames = frames;
                  meta.animation.rows[0].range = `0-${frames.length-1}`;
                  onMetaChange(meta, canvas);
                  document.querySelector('#glcanvas').getContext('webgl').getTextureFactory().cleanCache(meta.name);
                  Meta.addImage(canvas);
                }
              });
            }
          }
        }

        let imgCount = 0;
        function renderDirectory(obj) {
          fileSelection = -1;
          const { root } = obj;
          imgData = [];
          imgCount = obj.images.length;
          const htmls = [];
          {
            const elems = root.split('/');
            htmls.push('<div style="color: lightblue">');

            htmls.push(
              elems.map((elem, index) => {
                  return index==0 ? `${elem}` : `<span class="link" style="margin: 1px;" onClick="fillDir('${elems.slice(0, index+1).join('/')}')">${elem}</span>`;
              }).join("/")
            );

            htmls.push('</div>');
          }

          if (root) {
            htmls.push(`<div class='button' onClick="fillDir('${root.split('/').slice(0,-1).join('/')}')">ðŸ”™</div>`);
          }

          for(let i=0; i<obj.folders.length; i++) {
            const folder = obj.folders[i];
            htmls.push(`<div class='button' onClick="fillDir('${folder}')">${folder.split("/").pop()}</div>`);
          }

          htmls.push("<br>");

          for(let i=0; i<obj.images.length; i++) {
            const src = `/img/local/${encodeURIComponent(obj.images[i])}`;
            htmls.push(`<div title=${encodeURIComponent(obj.images[i].split("/").pop())} id="thumb_${i}" src="${src}" index="${i}" style='display: inline-block; width: 50px; height: 50px; border: 2px ${i===fileSelection?'#FFFFFF':'#282828'} solid; background-image: none; background-size: 100% auto; background-repeat: no-repeat; cursor: pointer;' onMouseDown="selectFile('${i}')"></div>`);
            const img = new Image();
            img.src = src;
            img.setAttribute('index', i);
            img.addEventListener('load', e => {
                const img = e.currentTarget;
                const div = document.getElementById('thumb_' + parseInt(img.getAttribute('index')));
                if (div && div.getAttribute('src')===src) {
                  process(imgData, parseInt(img.getAttribute('index')), img);
                  div.style.backgroundImage = `url(${img.src})`;
                }
            });
          }

          return htmls.join("\n");
        }

        function selectFile(fileIndex) {
          fileSelection = fileIndex;
          for(let i=0; document.getElementById(`thumb_${i}`); i++) {
            const div = document.getElementById(`thumb_${i}`);
            if(div.getAttribute('index')===fileSelection) {
              div.style.border = "2px #FFFFFF solid";
            } else {
              div.style.border = "2px #282828 solid";
            }
          }
        }

        function fillDir(root) {
          let recentPaths = localStorage.getItem("recentPaths");
          if(recentPaths) {
            document.getElementById('recentPaths').innerHTML =
              JSON.parse(recentPaths).map(path => {
                const folder = path.split("/").pop();
                return `<span class="link" style="margin: 2px;" onClick="fillDir('${path}')">../${folder}</span>`;
              });
          }

          checkImportButton(false);
          currentPath = root;
          const xhr = new XMLHttpRequest();
          xhr.open("GET", `/api/animations?root=${root}`, true);
          xhr.addEventListener('load', (e) => {
            const xhr = e.currentTarget;
            if (xhr.readyState === 4) {
              if (xhr.status === 200) {
                const obj = JSON.parse(xhr.responseText);
                document.getElementById('dir').innerHTML = renderDirectory(obj);
              } else {
                console.error(xhr.statusText);
              }
            }
          });
          xhr.send();
        }

        function generateMetaData(imgData, width, height) {
          let freezeFrames = [];
          for(var i=0; i<imgData.length; i++) {
            const tag = JSON.stringify({
              hotspot: imgData[i].hotspot,
              crop: imgData[i].spritesheetCrop,
            });
            if (freezeFrames.length === 0 || tag !== freezeFrames[freezeFrames.length-1].tag) {
              if(freezeFrames.length > 0) {
                freezeFrames[freezeFrames.length-1].end = i-1;
              }

              freezeFrames.push({
                tag: tag,
                start: i,
                hotspot: imgData[i].hotspot,
                crop: imgData[i].spritesheetCrop,
              });
            }
          }

          freezeFrames = freezeFrames.map(o => {
            return {
              range: `${o.start}-${o.end||imgData.length-1}`,
              hotspot: o.hotspot,
              crop: o.crop,
            };
          });

          return {
            name: imgData.length === 1 
              ? decodeURIComponent(imgData[0].img.src).split("/").pop().split(".")[0] 
              : currentPath.split("/").pop(),
            canvas: {
              width, height,
            },
            animation: {
              rows: [
                {
                  label: "default",
                  range: "0-" + (imgData.length-1),
                  frameRate: 60,
                  locked: true,                
                }
              ],
            },  
            frames: freezeFrames,
          };
        }

        function shiftHotspots(dx, dy) {
          meta.frames.forEach(frame => {
            frame.hotspot.x += dx * 2; 
            frame.hotspot.y += dy * 2;
          });
          const canvas = document.getElementById('spritesheet');
          onMetaChange(meta, canvas); 
          document.querySelector('#glcanvas').getContext('webgl').getTextureFactory().cleanCache(meta.name);
          Meta.addImage(canvas);
        }

        initialize();
</script>







<script>

  let scene = new SceneManager.Scene("mainscene");
  let scene2 = new SceneManager.Scene("uiscene");

  function initScene(scene) {
    scene.clear();
    if(meta && meta.animation) {
      const selectedLabel = meta.animation.rows[Math.min(meta.animation.rows.length-1,Math.max(selectedIndex, 0))].label;
      scene.onReveal(cell => {
        const { x, z } = cell;
        if (x===0 && z===0) {
          cell.setSprite(meta.name, selectedLabel);
          if(hasHotspot) {
            cell.setSprite('x', 'mark', 'xmark', 0, 0, 0, .1);
          }
        }
      });
    } else {
      scene.onReveal(cell => {
          const { x, z } = cell;
          cell.setWall('floor', 'floor');
          cell.setWall('ceiling', 'eye');
          if (x===-1 && Math.abs(z)%7!==3) {
            cell.setWall('leftwall', 'ice');            
          }
          if (x===-2 && Math.abs(z)%7!==3) {
            cell.setWall('rightwall', 'brick');            
          }
          if (x===1 && Math.abs(z)%7!==4) {
            cell.setWall('rightwall', 'ice');
          }
          if (x===2 && Math.abs(z)%7!==4) {
            cell.setWall('leftwall', 'brick');
          }
          if (x%11!== 3 && z===-1) {
            cell.setWall('wall', 'brick');
          }
          if (x%11!== 3 && z===-2) {
            cell.setWall('backwall', 'brick');            
          }
          if (Math.abs(x ^ z) % 13 === 10) {
            cell.setSprite('tentacle', null, null, 0, 0, 0, 1, .5);            
          }
          if (Math.abs(x ^ z) % 23 === 11) {
            cell.setSprite('blue-penguin', null, null, 0, 0, 0, .2, .2);
          }
          if (x===0 && z===0) {
            cell.setSprite('elephant', null, 'elephant', 0, 0, 0, 1, .9);
          }
          if (x===0&&z===1) {
            cell.setSprite('oozie', null, 'oozie', 0, 0, 0, .5);            
          }
          if (x===1 && z===0) {
            cell.setSprite('video', null, 'video', 0, 0, 0, 1, .9);
          }
      });
    }
  }

  function initUIScene(scene) {
    scene.clear();
  }

main();

//
// Start here
//
function main() {
  const canvas = document.querySelector('#glcanvas');
  const viewPosition = View.Camera.create(.5, 0, 4).setAutoTilt(true);
  const pointDown = { x: 0, y: 0 };
  function onMouse(e) {
    const { pageX, pageY } = e;
    switch(e.type) {
      case "mousemove":
        if(e.buttons === 1 && e.target.id==="glCanvas") {
            const dx = - (pageX - pointDown.x);
            const dy = - (pageY - pointDown.y);
            if (hasHotspot && meta && meta.animation) {
              shiftHotspots(dx, dy);
            } else {
              viewPosition.move(dx, 0, dy);
            }
        }
        pointDown.x = pageX;
        pointDown.y = pageY;
        break;
    }
  }

  const KEY_LEFT = 37;
  const KEY_RIGHT = 39;
  const KEY_UP = 38;
  const KEY_W = 87;
  const KEY_DOWN = 40;
  const KEY_S = 83;
  const KEY_A = 65;
  const KEY_D = 68;
  const KEY_Q = 81;
  const KEY_E = 69;
  const keyboard = [];
  function onKey(e) {
    if (!meta || !meta.animation) {
      switch(e.keyCode) {
        case KEY_LEFT: case KEY_RIGHT: case KEY_UP: case KEY_DOWN:
        case KEY_W: case KEY_S: case KEY_A: case KEY_D:
        case KEY_Q: case KEY_E:
          keyboard[e.keyCode] = e.type === "keyup" ? 0 : 1;
          updateMove(viewPosition);
          e.preventDefault();
          break;
      }
    }
  }

  function updateMove(camera) {
    let dx = 0, dz = 0, rot = 0;
    if (keyboard[KEY_UP] || keyboard[KEY_W]) {
      dz--;
    }
    if (keyboard[KEY_DOWN] || keyboard[KEY_S]) {
      dz++;
    }
    if (keyboard[KEY_LEFT] || keyboard[KEY_A]) {
      dx--;
    }
    if (keyboard[KEY_RIGHT] || keyboard[KEY_D]) {
      dx++;
    }
    if (keyboard[KEY_Q]) {
      rot --;
    }
    if (keyboard[KEY_E]) {
      rot ++;
    }
    if(dx || dz) {
      camera.move(dx, 0, dz);
    }
    if(rot) {
      camera.rotate(rot);
    }
  }

  document.addEventListener("mousemove", onMouse);
  document.addEventListener("keydown", onKey);
  document.addEventListener("keyup", onKey);


  function refreshCamera(camera, scene) {
    camera.step(scene);
    if(!meta || !meta.animation) {
      const [ x, y, z ] = camera.position;
      scene.setSprite("x", "mark", "xmark", x, 0, z - 1.5, .05);
    }    
  }

  Dowge.setScene("mainScene", scene);
  Dowge.setScene("uiScene", scene2);
  Dowge.setCamera("mainCamera", viewPosition);
  Dowge.renderCanvas(canvas, "mainScene", "mainCamera", (scene, camera, now) => {
    updateMove(camera);
    camera.step(scene);
    if(!meta || !meta.animation) {
      const [ x, y, z ] = camera.position;
      const { moveDirection } = camera;
      const dist = Math.sqrt(moveDirection.x * moveDirection.x + moveDirection.z * moveDirection.z);
      const relativeDirection = camera.getRelativePosition(moveDirection.x, 0, moveDirection.z);
      scene.setSprite("penguin", null, "penguin", x, 0, z - 1.5, .2, 0, null, dist < .01);
    }    
  });
  Dowge.renderCanvas(canvas, "uiScene", "mainCamera", (scene, camera, now) => {
      const [ x, y, z ] = camera.getRelativePosition(-.5, -0, 0);
      scene.setSprite("button", null, "ui", x, y, z, .1);
  });

  initScene(scene);
  initUIScene(scene2);
}



</script>

<script>
const video = document.createElement('video');
let videoPlaying = false;

function setupVideo(url) {
  video.loop = true;
  video.muted = true;
  video.addEventListener('playing', function() {
    const gl = document.querySelector('#glcanvas').getContext('webgl');
    gl.getTextureFactory().createTextureData('video', video.videoWidth, video.videoHeight)
      .attachVideo(video);
  }, true);

  video.addEventListener('timeupdate', function() {
  }, true);
  video.src = url;
}
//setupVideo("fragglerock.mp4")

document.addEventListener("keydown", e => {
  if(!videoPlaying) {
    video.play();
    videoPlaying = true;
  }
});
document.addEventListener("mousedown", e => {
  if(!videoPlaying) {
    video.play();
    videoPlaying = true;
  }
});


Meta.loadImage("card0001.png", console.log);

</script>